
---
111
## 1️⃣ **循环优化**

### ❌ 不要这样写：

```r
# 逐个元素循环
result <- numeric(n)
for (i in 1:n) {
  result[i] <- x[i] * 2 + 1
}
```

### ✅ 应该这样写：

```r
# 向量化操作
result <- x * 2 + 1
```

**提升：100-1000倍**

---

## 2️⃣ **数据框/矩阵逐行增长**

### ❌ 不要这样写：

```r
# rbind 逐行增长
df <- data.frame()
for (i in 1:10000) {
  df <- rbind(df, data.frame(x = i, y = i^2))
}
```

### ✅ 应该这样写：

```r
# 预分配空间
df <- data.frame(
  x = 1:10000,
  y = (1:10000)^2
)

# 或者用列表收集后合并
result_list <- vector("list", 10000)
for (i in 1:10000) {
  result_list[[i]] <- data.frame(x = i, y = i^2)
}
df <- do.call(rbind, result_list)
```

**提升：1000-10000倍**

---

## 3️⃣ **循环中重复调用函数**

### ❌ 不要这样写：

```r
for (i in 1:n) {
  result[i] <- x[i] + nrow(data)  # nrow 被调用 n 次
}
```

### ✅ 应该这样写：

```r
n_rows <- nrow(data)  # 只调用一次
result <- x + n_rows  # 向量化
```

**提升：10-100倍**

---

## 4️⃣ **隐式多重循环（筛选+聚合）**

### ❌ 不要这样写：

```r
result <- numeric(nrow(data))
for (i in 1:nrow(data)) {
  # 每次循环都筛选整个数据框
  subset_data <- data[data$group == data$group[i], ]
  result[i] <- mean(subset_data$value)
}
```

### ✅ 应该这样写：

```r
# 方法1：使用 ave
result <- ave(data$value, data$group, FUN = mean)

# 方法2：使用 aggregate + match
agg <- aggregate(value ~ group, data = data, FUN = mean)
result <- agg$value[match(data$group, agg$group)]

# 方法3：使用 dplyr
library(dplyr)
data <- data %>%
  group_by(group) %>%
  mutate(result = mean(value))
```

**提升：100-1000倍**

---

## 5️⃣ **apply 族函数 vs 向量化**

### ❌ 不要这样写：

```r
# apply 对每行求和
result <- apply(matrix, 1, sum)
```

### ✅ 应该这样写：

```r
# 使用内置的向量化函数
result <- rowSums(matrix)
```

**常用向量化函数：**

- `rowSums()`, `colSums()` 代替 `apply(x, 1/2, sum)`
- `rowMeans()`, `colMeans()` 代替 `apply(x, 1/2, mean)`
- `pmax()`, `pmin()` 代替 `apply(x, 1, max/min)`

**提升：10-50倍**

---

## 6️⃣ **条件判断**

### ❌ 不要这样写：

```r
result <- numeric(n)
for (i in 1:n) {
  if (x[i] > 0) {
    result[i] <- x[i]
  } else {
    result[i] <- 0
  }
}
```

### ✅ 应该这样写：

```r
# 向量化的 ifelse
result <- ifelse(x > 0, x, 0)

# 或者更快的索引方式
result <- x
result[result < 0] <- 0
```

**提升：50-100倍**

---

## 7️⃣ **字符串操作**

### ❌ 不要这样写：

```r
result <- character(n)
for (i in 1:n) {
  result[i] <- paste0("prefix_", x[i])
}
```

### ✅ 应该这样写：

```r
result <- paste0("prefix_", x)
```

**提升：50-200倍**

---

## 8️⃣ **矩阵运算**

### ❌ 不要这样写：

```r
# 双重循环计算矩阵
result <- matrix(0, nrow = n, ncol = m)
for (i in 1:n) {
  for (j in 1:m) {
    result[i, j] <- i + j
  }
}
```

### ✅ 应该这样写：

```r
# 使用 outer 或矩阵运算
result <- outer(1:n, 1:m, "+")

# 或者
result <- matrix(1:n, n, m) + matrix(1:m, n, m, byrow = TRUE)
```

**提升：100-500倍**

---

## 9️⃣ **数据读取**

### ❌ 不要这样写：

```r
# 逐行读取
data <- data.frame()
con <- file("data.txt", "r")
while(length(line <- readLines(con, n = 1)) > 0) {
  data <- rbind(data, parse_line(line))
}
close(con)
```

### ✅ 应该这样写：

```r
# 一次性读取
library(data.table)
data <- fread("data.txt")  # 最快

# 或
data <- read.csv("data.txt")  # 标准方法
```

**提升：100-1000倍**

---

## 🔟 **数据框操作**

### ❌ 不要这样写：

```r
# 逐列修改
for (col in names(data)) {
  data[[col]] <- data[[col]] * 2
}
```

### ✅ 应该这样写：

```r
# 向量化操作
data <- data * 2

# 或对数值列
numeric_cols <- sapply(data, is.numeric)
data[numeric_cols] <- data[numeric_cols] * 2
```

**提升：10-50倍**

---

## 1️⃣1️⃣ **逻辑索引 vs which**

### ⚖️ 场景不同：

```r
# 如果只需要筛选，直接用逻辑索引
result <- data[data$x > 10, ]  # 快

# 如果需要位置索引，用 which
indices <- which(data$x > 10)  # 然后可以多次使用 indices
```

---

## 1️⃣2️⃣ **样本抽样**

### ❌ 不要这样写：

```r
sampled <- data[sample(1:nrow(data), 1000), ]
```

### ✅ 应该这样写：

```r
# 对于大数据，直接用 dplyr
library(dplyr)
sampled <- data %>% slice_sample(n = 1000)
```

---

## 📊 **性能优化优先级排序：**

1. **避免数据框逐行增长**（rbind in loop）- 最重要！
2. **避免隐式多重循环**（筛选 + 循环）
3. **向量化操作** 代替 for 循环
4. **使用专用函数** 代替 apply
5. **提取循环不变量**
6. **使用 data.table 或 dplyr** 处理大数据

---

## 🛠️ **推荐的快速包：**

```r
library(data.table)  # 最快的数据处理
library(dplyr)       # 简洁的数据操作
library(Rcpp)        # C++ 集成（终极优化）
library(parallel)    # 并行计算
```

---

这个速查表基本涵盖了 **90% 的 R 语言性能优化场景**！